internal_f <- function(p, f) {
  stopifnot(is.character(p), length(p) == 1)
  stopifnot(is.character(f), length(f) == 1)

  get(f, envir = asNamespace(p))
}

"%||%" <- function(a, b) {
  if (length(a) > 0) a else b
}

subs <- matrix(ncol = 2, byrow = T, c(
  # Common special function names
  '[<-', 'subset',
  '[', 'sub',
  '<-', 'set',

  # Infix verbs
  '!', 'not',
  '&', 'and',
  '|', 'or',
  '*', 'times',
  '+', 'plus',
  '^', 'pow',

  # Others
  '"', 'quote',
  '#', 'hash',
  '$', 'cash',
  '%', 'grapes',
  "'", 'single-quote',
  '(', 'open-paren',
  ')', 'close-paren',
  ':', 'colon',
  ';', 'semi-colon',
  '<', 'less-than',
  '==', 'equals',
  '=', 'equals',
  '>', 'greater-than',
  '?', 'help',
  '@', 'at',
  ']', 'close-brace',
  '\\', 'backslash',
  '/', 'slash',
  '`', 'tick',
  '{', 'open-curly',
  '}', 'close',
  '~', 'twiddle'
))
subs[, 2] <- paste0("-", subs[, 2], "-")

nice_name <- function(x) {
  x <- stringi::stri_replace_all_fixed(x, subs[, 1], subs[, 2],
    vectorize_all = FALSE)

  # Clean up any remaining
  x <- str_replace_all(x, "[^A-Za-z0-9_.-]+", "-")
  x <- str_replace_all(x, "-+", "-")
  x <- str_replace_all(x, "^-|-$", "")
  x <- str_replace_all(x, "^\\.", "dot-")
  x
}

write_if_different <- function(path, contents, check = TRUE) {
  if (!file.exists(dirname(path))) {
    dir.create(dirname(path), showWarnings = FALSE)
  }

  if (check && !made_by_roxygen(path)) {
    warning("The existing '", basename(path),
      "' file was not generated by roxygen2, and will not be overwritten.",
      call. = FALSE, immediate. = TRUE)
    return(FALSE)
  }

  line_ending <- detect_line_ending(path)
  contents <- paste0(paste0(contents, collapse = line_ending), line_ending)
  contents <- enc2utf8(gsub("\r?\n", line_ending, contents))
  if (same_contents(path, contents)) return(FALSE)

  name <- basename(path)
  if (!str_detect(name, "^[a-zA-Z][a-zA-Z0-9_.-]*$")) {
    cat("Skipping invalid path: ", name, "\n")
    FALSE
  } else {
    cat(sprintf('Writing %s\n', name))
    writeBin(charToRaw(contents), path)
    TRUE
  }
}

same_contents <- function(path, contents) {
  if (length(contents) != 1) {
    stop("Internal roxygen error: `contents` must be character(1)")
  }
  if (!file.exists(path)) return(FALSE)

  text_hash <- digest::digest(contents, serialize = FALSE)

  path <- normalizePath(path, mustWork = TRUE)
  file_hash <- digest::digest(file = path)

  identical(text_hash, file_hash)
}

compact <- function(x) {
  x[!map_lgl(x, is.null)]
}

# Parse DESCRIPTION into convenient format
read.description <- function(file) {
  dcf <- desc::desc(file = file)

  fields <- dcf$fields()
  purrr::map(purrr::set_names(fields), ~ dcf$get_field(.x))
}

invert <- function(x) {
  if (length(x) == 0) return()
  stacked <- utils::stack(x)
  tapply(as.character(stacked$ind), stacked$values, list)
}

has_colons <- function(x) {
   grepl("::", x, fixed = TRUE)
}

# Collapse the values associated with duplicated keys
collapse <- function(key, value, fun, ...) {
  stopifnot(is.character(key))
  stopifnot(length(key) == length(value))

  dedup <- tapply(value, key, fun, ..., simplify = FALSE)
  # tapply orders alphabetically, so reorder to match original order
  dedup <- dedup[unique(key)]

  list(
    key = names(dedup),
    value = unname(dedup)
  )
}

cat_line <- function(...) {
  cat(paste0(..., "\n", collapse = ""))
}

tag_aliases <- function(f) {
  paste0("@aliases ", paste0("@", names(f()), collapse = " "))
}

pkg_env <- function() {
  env <- new.env(parent = globalenv())
  env$.packageName <- "roxygen2"
  env
}

uuid <- function(nchar = 8) {
  paste(
    sample(c(letters, LETTERS, 0:9), nchar, replace = TRUE),
    collapse = ""
  )
}

find_topic_in_package <- function(pkg, topic) {
  raw_topic <- str_trim(tools::parse_Rd(textConnection(topic))[[1]][1])
  basename(utils::help((raw_topic), (pkg))[1])
}

find_topic_filename <- function(pkg, topic, tag, force = TRUE) {
  # This is needed because we have the escaped text here, and parse_Rd will
  # un-escape it properly.
  if (is.na(pkg) || identical(roxy_meta_get("current_package"), pkg)) {
    id <- roxy_meta_get("link_id")
    if (!is.null(id)) {
      # id is only NULL in test cases, not in roxygenize()
      file <- URLencode(basename(tag$file), TRUE, TRUE)
      paste0(id, ",", force + 0, ",", file, ",", tag$line, ",", topic, ",", id)
    } else {
      topic
    }
  } else {
    path <- tryCatch(
      find_topic_in_package(pkg, topic),
      error = function(err) {
        roxy_tag_warning(tag, "Link to unavailable package: ", pkg, ". ", err$message)
        topic
      }
    )
    if (is.na(path)) {
      roxy_tag_warning(tag, "Link to unknown topic: ", topic, " in package ", pkg)
      topic
    } else {
      path
    }
  }
}

fix_link_to_file <- function(str, linkmap) {
  id <- roxy_meta_get("link_id")
  idlen <- nchar(id)
  nopkg <- FALSE
  if (substr(str, 1, 1) == "[") {
    nopkg <- TRUE
    str <- substr(str, 3, nchar(str) - 1)
  }
  pieces <- strsplit(str, ",", fixed = TRUE)[[1]]
  topic <- pieces[5]
  filename <- linkmap[[topic]]
  if (length(filename) == 0) {
    # TODO: show original file name and line number
    roxy_warning("Link to unknown topic '", topic, "'")
    filename <- topic
  }
  # Do we need an explicit file name at all?
  if (filename[1] == topic && nopkg && pieces[2] == "0") {
    ""
  } else {
    paste0("[=", filename[1], "]")
  }
}

# quoting -----------------------------------------------------------------
auto_backtick <- function(x) {
  needs_backtick <- !has_quotes(x) & !is_syntactic(x)
  x[needs_backtick] <- encodeString(x[needs_backtick], quote = "`")
  x
}

auto_quote <- function(x) {
  needs_quotes <- !has_quotes(x) & !is_syntactic(x)
  x[needs_quotes] <- encodeString(x[needs_quotes], quote = '"')
  x
}

is_syntactic <- function(x) make.names(x) == x
has_quotes <- function(x) str_detect(x, "^(`|'|\").*\\1$")
